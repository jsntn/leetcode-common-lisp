;;; 对两个链表进行遍历，重复的代码有点多
(defun add-two-numbers (l1 l2)
  (let ((res nil)
        (quotient)
        (remainder 0))
    (loop while (and l1 l2) do
         (setf (values remainder quotient)
               (floor (+ (car l1) (car l2) remainder) 10))
         (push quotient res)
         (setf l1 (cdr l1))
         (setf l2 (cdr l2)))
    (loop while l1 do
         (setf (values remainder quotient)
               (floor (+ (car l1) remainder) 10))
         (push quotient res)
         (setf l1 (cdr l1)))
    (loop while l2 do
         (setf (values remainder quotient)
               (floor (+ (car l2) remainder) 10))
         (push quotient res)
         (setf l2 (cdr l2)))
    (if (> remainder 0)
        (reverse (push remainder res))
        (reverse res))))

;;; 将重复的 loop while 部分进行抽取，勉强弄成这样
(defmacro lw ((lst &optional (another '(0))) &body body)
  `(loop while (and ,lst ,another) do
        (setf (values remainder quotient)
              (floor (+ (car ,lst)
                        (car ,another)
                        remainder) 10))
        (push quotient res)
        ,@body))

(defun add-two-numbers (l1 l2)
  (let ((res nil)
        (quotient)
        (remainder 0))
    (lw (l1 l2)
        (setf l1 (cdr l1))
        (setf l2 (cdr l2)))
    (lw (l1 '(0))
        (setf l1 (cdr l1)))
    (lw (l2 '(0))
        (setf l2 (cdr l2)))
    (if (> remainder 0)
        (reverse (push remainder res))
        (reverse res))))